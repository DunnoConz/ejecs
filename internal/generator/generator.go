package generator

import (
	"bytes"
	"fmt"
	"strings"

	"github.com/ejecs/ejecs/internal/ast"
)

// Config holds the configuration for the generator
// type Config struct { // Removed Config struct
// 	Library string // Target library (ecr, jecs)
// }

// Generator handles the code generation process
type Generator struct {
	buffer bytes.Buffer
	indent int
}

// New creates a new Generator instance
// func New(config Config) *Generator { // Old New function signature
func New() *Generator { // Simplified New function signature
	return &Generator{}
}

// Generate generates the complete Luau module code from the AST Program
func (g *Generator) Generate(program *ast.Program) (string, error) {
	g.buffer.Reset()
	g.indent = 0

	// Write header
	g.writeHeader()

	// Process each statement
	for i, stmt := range program.Statements {
		switch n := stmt.(type) {
		case *ast.Component:
			if err := g.generateComponent(n); err != nil {
				return "", err
			}
		case *ast.System:
			// Add the wrapper here
			g.writeLine("world:system({")
			g.indent++
			if err := g.generateSystem(n); err != nil {
				return "", err
			}
			g.indent--
			g.writeLine("})")
		case *ast.Relationship:
			if err := g.generateRelationship(n); err != nil {
				return "", err
			}
		default:
			return "", fmt.Errorf("unknown statement node type in Generate: %T", n)
		}

		if i < len(program.Statements)-1 {
			g.writeLine("") // Add blank line between statements
		}
	}

	// Write footer
	g.writeFooter()

	return g.buffer.String(), nil
}

// generateStatement dispatches generation to specific functions based on statement type
func (g *Generator) generateStatement(node ast.Node) error {
	switch n := node.(type) {
	case *ast.Component:
		return g.generateComponent(n)
	case *ast.System:
		return g.generateSystem(n)
	case *ast.Relationship:
		return g.generateRelationship(n)
	default:
		return fmt.Errorf("unknown statement node type in Generate: %T", n)
	}
}

// writeHeader generates the initial Luau module setup
func (g *Generator) writeHeader() {
	g.writeLine("-- Generated by EJECS IDL Compiler --")
	g.writeLine("local Module = {}")
	g.writeLine("")
	g.writeLine("Module.Components = {}")
	g.writeLine("")
}

// writeFooter generates the final return statement for the Luau module
func (g *Generator) writeFooter() {
	g.writeLine("")
	g.writeLine("return Module")
}

// Helper function to write a line with current indentation (simplified for now)
func (g *Generator) writeLine(line string) {
	g.buffer.WriteString(g.indentString() + line + "\n")
}

// --- Expression Generation ---

func (g *Generator) generateExpression(expr ast.Expression) (string, error) {
	switch e := expr.(type) {
	case *ast.Identifier:
		return g.generateIdentifier(e)
	case *ast.NumberLiteral:
		return g.generateNumberLiteral(e)
	case *ast.StringLiteral:
		return g.generateStringLiteral(e)
	case *ast.BooleanLiteral:
		return g.generateBooleanLiteral(e)
	case *ast.TableConstructor:
		return g.generateTableConstructor(e)
	case *ast.CallExpression:
		return g.generateCallExpression(e)
	case *ast.PrefixExpression:
		return g.generatePrefixExpression(e)
	case *ast.MemberAccessExpression:
		return g.generateMemberAccessExpression(e)
	// TODO: Add cases for other expression types (infix, prefix, member access, etc.)
	default:
		return "", fmt.Errorf("unknown expression type in generator: %T", e)
	}
}

func (g *Generator) generateIdentifier(ident *ast.Identifier) (string, error) {
	// For now, just return the identifier name. Might need mapping later.
	return ident.Value, nil
}

func (g *Generator) generateNumberLiteral(num *ast.NumberLiteral) (string, error) {
	// Assume the literal value is already a valid Luau number string
	return num.Value, nil
}

func (g *Generator) generateStringLiteral(str *ast.StringLiteral) (string, error) {
	// Need to ensure it's properly quoted for Luau
	return fmt.Sprintf("%q", str.Value), nil
}

func (g *Generator) generateBooleanLiteral(b *ast.BooleanLiteral) (string, error) {
	if b.Value {
		return "true", nil
	} else {
		return "false", nil
	}
}

func (g *Generator) generateTableConstructor(tbl *ast.TableConstructor) (string, error) {
	var sb strings.Builder
	sb.WriteString("{")

	needsNewline := len(tbl.Fields) > 1 // Add newline/indentation for multi-line tables
	if needsNewline {
		sb.WriteString("\n")
		g.indent++
	}

	for i, field := range tbl.Fields {
		if field.Key != nil {
			keyStr, err := g.generateExpression(field.Key)
			if err != nil {
				return "", err
			}
			// Handle different key types for Luau syntax ([expr] vs ident)
			switch field.Key.(type) {
			case *ast.StringLiteral:
				keyStr = fmt.Sprintf("[%s]", keyStr) // e.g., ["key"]
			case *ast.NumberLiteral:
				keyStr = fmt.Sprintf("[%s]", keyStr) // e.g., [1]
			case *ast.Identifier:
				// Keep as is for ident = value
			default:
				// Other expression types also need brackets
				keyStr = fmt.Sprintf("[%s]", keyStr)
			}
			sb.WriteString(g.indentString() + keyStr + " = ")
		} else {
			// Array-style value
			sb.WriteString(g.indentString())
		}

		valueStr, err := g.generateExpression(field.Value)
		if err != nil {
			return "", err
		}
		sb.WriteString(valueStr)

		if i < len(tbl.Fields)-1 {
			sb.WriteString(",")
		}
		if needsNewline {
			sb.WriteString("\n")
		}
	}

	if needsNewline {
		g.indent--
		sb.WriteString(g.indentString())
	}
	sb.WriteString("}")
	return sb.String(), nil
}

func (g *Generator) generateCallExpression(call *ast.CallExpression) (string, error) {
	// Basic placeholder - generates FunctionName(...)
	// TODO: Generate arguments properly
	funcStr, err := g.generateExpression(call.Function)
	if err != nil {
		return "", err
	}
	// Simple arg generation for now
	argStrs := []string{}
	for _, arg := range call.Arguments {
		argStr, err := g.generateExpression(arg)
		if err != nil {
			return "", err
		}
		argStrs = append(argStrs, argStr)
	}
	return fmt.Sprintf("%s(%s)", funcStr, strings.Join(argStrs, ", ")), nil
}

// Generate code for PrefixExpression
func (g *Generator) generatePrefixExpression(pe *ast.PrefixExpression) (string, error) {
	rightStr, err := g.generateExpression(pe.Right)
	if err != nil {
		return "", err
	}
	// Combine operator and operand (e.g., "-10")
	return pe.Operator + rightStr, nil
}

// Generate code for MemberAccessExpression
func (g *Generator) generateMemberAccessExpression(ma *ast.MemberAccessExpression) (string, error) {
	leftStr, err := g.generateExpression(ma.Object)
	if err != nil {
		return "", err
	}
	// Assume MemberName is always simple identifier for now
	return fmt.Sprintf("%s.%s", leftStr, ma.MemberName.Value), nil
}

// Update getDefaultValue to call generateExpression
func (g *Generator) getDefaultValue(defaultValue ast.Expression, fieldType string, isOptional bool) string {
	if defaultValue != nil {
		genStr, err := g.generateExpression(defaultValue)
		if err != nil {
			// Handle generation error - maybe return an error comment?
			return fmt.Sprintf("nil --[[ ERROR generating default value: %v ]]", err)
		}
		return genStr
	}

	// Handle optional types if no explicit default was given
	if isOptional {
		return "nil"
	}

	// Generate default based on type if no explicit default and not optional
	switch fieldType {
	case "int", "float", "number":
		return "0"
	case "string":
		return "\"\""
	case "boolean":
		return "false"
	case "Vector2":
		return "Vector2.new(0, 0)"
	case "Vector3":
		return "Vector3.new(0, 0, 0)"
	case "CFrame":
		return "CFrame.new()"
	case "Color3":
		return "Color3.new(1, 1, 1)"
	case "UDim2":
		return "UDim2.new(0, 0, 0, 0)"
	case "UDim":
		return "UDim.new(0, 0)"
	case "table":
		return "{}"
	default:
		return "nil"
	}
}

// --- Placeholder/Simplified implementations for specific types ---

func (g *Generator) generateComponent(comp *ast.Component) error {
	// Handle component attributes (e.g., @Type)
	for _, attr := range comp.Attributes {
		// Attributes might affect generation logic later, store or handle them
		// For now, we might just write them as comments or ignore if not used
		g.writeLine(fmt.Sprintf("-- Component Attribute: @%s", attr))
	}

	// Use Module.Components. prefix again
	g.writeLine(fmt.Sprintf("Module.Components.%s = {", comp.Name))
	g.indent++
	for i, field := range comp.Fields {
		// Handle field attributes
		// for _, attr := range field.Attributes {
		// 	g.writeLine(fmt.Sprintf("-- Field Attribute: @%s", attr.Value))
		// }

		// Generate default value string
		defaultValueStr := g.getDefaultValue(field.DefaultValue, field.Type, field.Optional)

		comma := ","
		if i == len(comp.Fields)-1 {
			// Special handling if the default value itself is a multi-line table
			isTable, _ := field.DefaultValue.(*ast.TableConstructor)
			// No comma if single line & last & not a table (or nil default)
			if !strings.Contains(defaultValueStr, "\n") && isTable == nil {
				comma = ""
			}
		}
		// Optional fields aren't directly represented in Luau table definitions this way
		// The default value handling (returning "nil") covers the optional aspect.
		g.writeLine(fmt.Sprintf("%s = %s%s", field.Name, defaultValueStr, comma))

	}
	g.indent--
	g.writeLine("}")
	return nil
}

func (g *Generator) generateSystem(system *ast.System) error {
	// This function now generates ONLY the *content* of the system table
	// The Generate function will add the world:system wrapper

	// System Name
	g.writeLine(fmt.Sprintf("name = %q,", system.Name))

	// Parameters
	if len(system.Parameters) > 0 {
		g.writeLine("parameters = {")
		g.indent++
		for i, param := range system.Parameters {
			var defaultValueStr string
			var err error
			if param.DefaultValue != nil {
				defaultValueStr, err = g.generateExpression(param.DefaultValue)
				if err != nil {
					defaultValueStr = fmt.Sprintf("nil --[[ ERROR generating default value: %v ]]", err)
				}
			} else {
				// Get default based on type if no explicit default value is provided
				defaultValueStr = g.getDefaultValue(nil, param.Type, false) // Params usually aren't optional, default to false
			}

			comma := ","
			if i == len(system.Parameters)-1 {
				comma = "" // No comma for the last item
			}
			g.writeLine(fmt.Sprintf("%s = %s%s", param.Name, defaultValueStr, comma))
		}
		g.indent--
		g.writeLine("},")
	}

	// Query
	if system.Query != nil && len(system.Query.Components) > 0 { // Check if query exists
		g.writeLine("query = {")
		g.indent++
		g.writeLine("all = {")
		g.indent++
		for i, comp := range system.Query.Components {
			comma := ","
			if i == len(system.Query.Components)-1 {
				comma = ""
			}
			// Output component names directly, without quotes
			g.writeLine(fmt.Sprintf("%s%s", comp, comma))
		}
		g.indent--
		g.writeLine("},") // Comma after 'all'

		if len(system.Query.Relations) > 0 {
			g.writeLine("relations = {")
			g.indent++
			for i, rel := range system.Query.Relations {
				comma := ","
				if i == len(system.Query.Relations)-1 {
					comma = ""
				}
				// Output relation type and component name directly, without quotes
				g.writeLine(fmt.Sprintf("%s = %s%s", rel.Type, rel.Component, comma))
			}
			g.indent--
			g.writeLine("},") // Comma after 'relations'
		}

		g.indent--
		g.writeLine("},") // Comma after 'query' block
	}

	// Frequency
	if system.Frequency != nil {
		freqStr, err := g.generateExpression(system.Frequency)
		if err != nil {
			freqStr = fmt.Sprintf("nil --[[ ERROR: %v ]]", err)
		}
		g.writeLine(fmt.Sprintf("frequency = %s,", freqStr))
	}

	// Priority
	if system.Priority != nil {
		prioStr, err := g.generateExpression(system.Priority)
		if err != nil {
			prioStr = fmt.Sprintf("nil --[[ ERROR: %v ]]", err)
		}
		g.writeLine(fmt.Sprintf("priority = %s,", prioStr))
	}

	// Callback
	if system.Code != "" {
		var args []string
		args = append(args, "entity", "components") // Base arguments
		if len(system.Parameters) > 0 {
			for _, param := range system.Parameters {
				args = append(args, param.Name)
			}
		}

		g.writeLine("callback = function(" + strings.Join(args, ", ") + ")")
		g.indent++ // Indent for the code block content

		// Process code block content line by line
		codeLines := strings.Split(strings.TrimSpace(system.Code), "\n")
		for _, line := range codeLines {
			trimmedLine := strings.TrimRight(line, " \t")
			g.writeLine(trimmedLine)
		}

		g.indent--          // Dedent after the code block
		g.writeLine("end,") // Add comma after callback function
	}

	// Remove trailing comma cleanly
	// This needs to be done *after* all potential fields are written
	currentBuffer := g.buffer.Bytes()
	if bytes.HasSuffix(currentBuffer, []byte(",\n")) {
		g.buffer.Truncate(g.buffer.Len() - 2) // Remove ",\n"
		g.buffer.WriteString("\n")            // Add back the newline
	}

	// DO NOT write closing brace here, Generate function will do it.
	return nil
}

func (g *Generator) write(s string) {
	g.buffer.WriteString(g.indentString() + s)
}

// Helper for indentation (can be more sophisticated)
func (g *Generator) indentString() string {
	if g.indent < 0 {
		g.indent = 0
	}
	return strings.Repeat("    ", g.indent)
}

func (g *Generator) generateRelationship(rel *ast.Relationship) error {
	// Add attribute if present, BEFORE the relationship line
	if rel.Type != "" {
		g.writeLine(fmt.Sprintf("@%s", rel.Type))
	}
	// Relationship definition
	g.writeLine(fmt.Sprintf("relationship %s {", rel.Name))
	g.indent++ // Indent relationship body
	g.writeLine(fmt.Sprintf("child: %s", rel.Child))
	g.writeLine(fmt.Sprintf("parent: %s", rel.Parent))
	g.indent-- // Dedent after body
	g.writeLine("}")
	return nil
}

// Remove generateSystemWithIndent and other unused helpers if they exist

func luauType(t string) string {
	switch t {
	case "number":
		return "number"
	case "string":
		return "string"
	case "boolean":
		return "boolean"
	default:
		return "any"
	}
}
