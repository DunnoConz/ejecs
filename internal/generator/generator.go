package generator

import (
	"bytes"
	"fmt"
	"strings"

	"github.com/ejecs/ejecs/internal/ast"
)

type Generator struct {
	buffer bytes.Buffer
}

func New() *Generator {
	return &Generator{}
}

func (g *Generator) Generate(program *ast.Program) (string, error) {
	// Write header
	g.writeHeader()

	// Generate components
	for _, comp := range program.Components {
		g.generateComponent(comp)
	}

	// Generate relationships
	for _, rel := range program.Relationships {
		g.generateRelationship(rel)
	}

	// Generate systems
	for _, sys := range program.Systems {
		g.generateSystem(sys)
	}

	return g.buffer.String(), nil
}

func (g *Generator) writeHeader() {
	g.writeLine("-- Generated by JECS IDL Compiler")
	g.writeLine("local jecs = require(game.ReplicatedStorage.jecs)")
	g.writeLine("local world = jecs.World.new()")
	g.writeLine("")
}

func (g *Generator) generateComponent(comp *ast.Component) {
	g.writeLine(fmt.Sprintf("-- Component: %s", comp.Name))
	g.writeLine(fmt.Sprintf("local %s = world:component()", comp.Name))

	// Generate type definition if needed
	if len(comp.Fields) > 0 {
		g.writeLine(fmt.Sprintf("type %sData = {", comp.Name))
		for _, field := range comp.Fields {
			g.writeLine(fmt.Sprintf("    %s: %s,", field.Name, luauType(field.Type)))
		}
		g.writeLine("}")
		g.writeLine("")
	}
}

func (g *Generator) generateRelationship(rel *ast.Relationship) {
	g.writeLine(fmt.Sprintf("-- Relationship: %s", rel.Name))
	g.writeLine(fmt.Sprintf("local %s = world:component()", rel.Name))
	g.writeLine("")
}

func (g *Generator) generateSystem(sys *ast.System) {
	g.writeLine(fmt.Sprintf("-- System: %s", sys.Name))
	g.writeLine("world:system({")
	g.writeLine(fmt.Sprintf("    name = \"%s\",", sys.Name))

	// Generate query
	if sys.Query != nil {
		g.generateQuery(sys.Query)
	}

	// Generate callback
	g.writeLine("    callback = function(entity, components)")
	if sys.Code != "" {
		// Extract components from query for parameter mapping
		var paramMap []string
		if sys.Query != nil {
			// Add helper functions for relationships
			hasRelations := false
			for _, rel := range sys.Query.Relations {
				if rel.Target == "*" {
					paramMap = append(paramMap, fmt.Sprintf("local %s = components.%s", strings.ToLower(rel.Type), rel.Type))
					paramMap = append(paramMap, fmt.Sprintf("local %sTarget = world:getTarget(entity, %s)", strings.ToLower(rel.Type), rel.Type))
				} else {
					paramMap = append(paramMap, fmt.Sprintf("local %s = components.%s", strings.ToLower(rel.Target), rel.Target))
				}
				hasRelations = true
			}

			// Add regular components
			for _, comp := range sys.Query.Components {
				paramMap = append(paramMap, fmt.Sprintf("local %s = components.%s", strings.ToLower(comp), comp))
			}

			if hasRelations {
				g.writeLine("        -- Get relationship targets")
			}
		}

		// Add parameter mappings
		for _, param := range paramMap {
			g.writeLine(fmt.Sprintf("        %s", param))
		}
		g.writeLine("")

		// Add code
		for _, line := range strings.Split(sys.Code, "\n") {
			line = strings.TrimSpace(line)
			if line != "" {
				// Handle special cases for better formatting
				line = strings.ReplaceAll(line, " . ", ".")
				line = strings.ReplaceAll(line, " , ", ", ")
				line = strings.ReplaceAll(line, "( ", "(")
				line = strings.ReplaceAll(line, " )", ")")
				line = strings.ReplaceAll(line, "+ =", "+=")
				line = strings.ReplaceAll(line, "parent", "childofTarget") // Replace parent with actual target
				g.writeLine(fmt.Sprintf("        %s", line))
			}
		}
	}
	g.writeLine("    end")
	g.writeLine("})")
	g.writeLine("")
}

func (g *Generator) generateQuery(query *ast.Query) {
	g.writeLine("    query = {")

	// Generate components
	for i, comp := range query.Components {
		if i == len(query.Components)-1 && len(query.Relations) == 0 {
			g.writeLine(fmt.Sprintf("        %s", comp))
		} else {
			g.writeLine(fmt.Sprintf("        %s,", comp))
		}
	}

	// Generate relations
	for i, rel := range query.Relations {
		if i == len(query.Relations)-1 {
			g.writeLine(fmt.Sprintf("        pair(%s, %s)", rel.Type, rel.Target))
		} else {
			g.writeLine(fmt.Sprintf("        pair(%s, %s),", rel.Type, rel.Target))
		}
	}

	g.writeLine("    },")
}

func (g *Generator) writeLine(line string) {
	g.buffer.WriteString(line + "\n")
}

func luauType(t string) string {
	switch t {
	case "number":
		return "number"
	case "string":
		return "string"
	case "boolean":
		return "boolean"
	default:
		return "any"
	}
}
