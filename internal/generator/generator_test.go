package generator

import (
	"regexp"
	"strings"
	"testing"

	"github.com/ejecs/ejecs/internal/ast"
	"github.com/stretchr/testify/assert"
)

// normalizeWhitespace removes insignificant whitespace differences
func normalizeWhitespace(s string) string {
	// Remove empty lines
	s = regexp.MustCompile(`(?m)^\s*$`).ReplaceAllString(s, "")

	// Normalize indentation to 4 spaces
	s = regexp.MustCompile(`(?m)^[\t ]+`).ReplaceAllString(s, "    ")

	// Remove trailing commas in arrays/objects
	s = regexp.MustCompile(`,(\s*[}\]])`).ReplaceAllString(s, "$1")

	// Normalize spaces around operators and commas
	s = regexp.MustCompile(`\s*([-+*/=,])\s*`).ReplaceAllString(s, "$1")

	// Normalize spaces in function declarations
	s = regexp.MustCompile(`function\s*\(`).ReplaceAllString(s, "function(")

	// Remove extra spaces in parameter lists
	s = regexp.MustCompile(`\(\s+`).ReplaceAllString(s, "(")
	s = regexp.MustCompile(`\s+\)`).ReplaceAllString(s, ")")

	// Normalize spaces after commas in parameter lists
	s = regexp.MustCompile(`,\s*([a-zA-Z])`).ReplaceAllString(s, ", $1")

	// Normalize spaces around braces
	s = regexp.MustCompile(`{\s+`).ReplaceAllString(s, "{")
	s = regexp.MustCompile(`\s+}`).ReplaceAllString(s, "}")

	// Normalize spaces around brackets
	s = regexp.MustCompile(`\[\s+`).ReplaceAllString(s, "[")
	s = regexp.MustCompile(`\s+\]`).ReplaceAllString(s, "]")

	// Normalize spaces around parentheses
	s = regexp.MustCompile(`\(\s+`).ReplaceAllString(s, "(")
	s = regexp.MustCompile(`\s+\)`).ReplaceAllString(s, ")")

	// Normalize spaces around semicolons
	s = regexp.MustCompile(`\s*;\s*`).ReplaceAllString(s, ";")

	// Normalize spaces around dots
	s = regexp.MustCompile(`\s*\.\s*`).ReplaceAllString(s, ".")

	// Normalize spaces around colons
	s = regexp.MustCompile(`\s*:\s*`).ReplaceAllString(s, ":")

	// Normalize newlines
	s = regexp.MustCompile(`\r\n|\r|\n`).ReplaceAllString(s, "\n")

	// Normalize multiple spaces
	s = regexp.MustCompile(`\s+`).ReplaceAllString(s, " ")

	// Trim trailing whitespace
	s = regexp.MustCompile(`(?m)[ \t]+$`).ReplaceAllString(s, "")

	return strings.TrimSpace(s)
}

// Helper function to compare strings ignoring whitespace differences
func assertEqualIgnoringWhitespace(t *testing.T, expected, actual string) {
	t.Helper()
	normalizedExpected := strings.Join(strings.Fields(expected), " ")
	normalizedActual := strings.Join(strings.Fields(actual), " ")
	assert.Equal(t, normalizedExpected, normalizedActual)
}

func TestGenerator_Component(t *testing.T) {
	tests := []struct {
		name     string
		comp     *ast.Component
		expected string // Expected *full module* output for this single component
	}{
		{
			name: "basic component",
			comp: &ast.Component{
				Name: "Position",
				Fields: []*ast.Field{
					{Name: "x", Type: "number"},
					{Name: "y", Type: "number"},
				},
			},
			expected: `
-- Generated by EJECS IDL Compiler --
local Module = {}

Module.Components = {}

Module.Components.Position = {
    x = 0,
    y = 0
}

return Module
`,
		},
		{
			name: "component with attributes",
			comp: &ast.Component{
				Name:       "Player",
				Attributes: []string{"replicated", "networked"},
				Fields: []*ast.Field{
					{Name: "name", Type: "string"},
					{Name: "health", Type: "number"},
				},
			},
			expected: `
-- Generated by EJECS IDL Compiler --
local Module = {}

Module.Components = {}

-- Component Attribute: @replicated
-- Component Attribute: @networked
Module.Components.Player = {
    name = "",
    health = 0
}

return Module
`,
		},
		{
			name: "component with defaults",
			comp: &ast.Component{
				Name: "Config",
				Fields: []*ast.Field{
					{Name: "speed", Type: "number", DefaultValue: &ast.NumberLiteral{Value: "10.5"}},
					{Name: "enabled", Type: "boolean", DefaultValue: &ast.BooleanLiteral{Value: true}},
					{Name: "title", Type: "string", DefaultValue: &ast.StringLiteral{Value: "Default Title"}},
				},
			},
			expected: `
-- Generated by EJECS IDL Compiler --
local Module = {}

Module.Components = {}

Module.Components.Config = {
    speed = 10.5,
    enabled = true,
    title = "Default Title"
}

return Module
`,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			g := New()
			program := &ast.Program{
				Statements: []ast.Node{tt.comp},
			}
			got, err := g.Generate(program)
			if err != nil {
				t.Fatalf("Generate() error = %v", err)
			}
			assertEqualIgnoringWhitespace(t, tt.expected, got)
		})
	}
}

func TestGenerator_System(t *testing.T) {
	tests := []struct {
		name     string
		sys      *ast.System
		expected string // Expected *full module* output for this single system
	}{
		{
			name: "basic system",
			sys: &ast.System{
				Name: "Movement",
				Query: &ast.Query{
					Components: []string{"Position", "Velocity"},
				},
				Code: "    pos.x = pos.x + vel.x;\n    pos.y = pos.y + vel.y;", // Keep relative indent
			},
			expected: `
-- Generated by EJECS IDL Compiler --
local Module = {}

Module.Components = {}

world:system({
    name = "Movement",
    query = {
        all = {
            Position,
            Velocity
        },
    },
    callback = function(entity, components)
        pos.x = pos.x + vel.x;
        pos.y = pos.y + vel.y;
    end
})

return Module
`,
		},
		{
			name: "system with frequency and priority",
			sys: &ast.System{
				Name: "Physics",
				Query: &ast.Query{
					Components: []string{"RigidBody"},
				},
				Frequency: &ast.Identifier{Value: "60hz"}, // Assuming Identifier is correct AST type here
				Priority:  &ast.NumberLiteral{Value: "1"}, // Use NumberLiteral for Priority
				Code:      "        body.simulate();",
			},
			expected: `
-- Generated by EJECS IDL Compiler --
local Module = {}

Module.Components = {}

world:system({
    name = "Physics",
    query = {
        all = {
            RigidBody
        },
    },
    frequency = 60hz,
    priority = 1,
    callback = function(entity, components)
        body.simulate();
    end
})

return Module
`,
		},
		{
			name: "system with parameters",
			sys: &ast.System{
				Name: "Damage",
				Parameters: []*ast.Parameter{
					{Name: "amount", Type: "number"},
					{Name: "source", Type: "string", DefaultValue: &ast.StringLiteral{Value: "unknown"}},
				},
				Query: &ast.Query{
					Components: []string{"Health"},
				},
				Code: "    health.current = health.current - amount;\n    print(\"Damage from: \" .. source)",
			},
			expected: `
-- Generated by EJECS IDL Compiler --
local Module = {}

Module.Components = {}

world:system({
    name = "Damage",
    parameters = {
        amount = 0,
        source = "unknown"
    },
    query = {
        all = {
            Health
        },
    },
    callback = function(entity, components, amount, source)
        health.current = health.current - amount;
        print("Damage from: " .. source)
    end
})

return Module
`,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			g := New()
			program := &ast.Program{
				Statements: []ast.Node{tt.sys},
			}
			got, err := g.Generate(program)
			if err != nil {
				t.Fatalf("Generate() error = %v", err)
			}
			assertEqualIgnoringWhitespace(t, tt.expected, got)
		})
	}
}

func TestGenerator_Relationship(t *testing.T) {
	tests := []struct {
		name     string
		rel      *ast.Relationship
		expected string // Expected *full module* output
	}{
		{
			name: "basic relationship",
			rel: &ast.Relationship{
				Name:   "ParentChild",
				Child:  "Child",
				Parent: "Parent",
			},
			expected: `
-- Generated by EJECS IDL Compiler --
local Module = {}

Module.Components = {}

relationship ParentChild {
    child: Child
    parent: Parent
}

return Module
`,
		},
		{
			name: "relationship with type",
			rel: &ast.Relationship{
				Type:   "hierarchical", // Ensure Type field is populated in AST
				Name:   "ManagedBy",
				Child:  "Employee",
				Parent: "Manager",
			},
			expected: `
-- Generated by EJECS IDL Compiler --
local Module = {}

Module.Components = {}

@hierarchical
relationship ManagedBy {
    child: Employee
    parent: Manager
}

return Module
`,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			g := New()
			program := &ast.Program{
				Statements: []ast.Node{tt.rel},
			}
			got, err := g.Generate(program)
			if err != nil {
				t.Fatalf("Generate() error = %v", err)
			}
			assertEqualIgnoringWhitespace(t, tt.expected, got)
		})
	}
}

func TestGenerator_Complete(t *testing.T) {
	program := &ast.Program{
		Statements: []ast.Node{
			&ast.Component{
				Name: "Position",
				Fields: []*ast.Field{
					{Name: "x", Type: "number"},
					{Name: "y", Type: "number"},
				},
			},
			&ast.Component{
				Name: "Velocity",
				Fields: []*ast.Field{
					{Name: "dx", Type: "number"},
					{Name: "dy", Type: "number"},
				},
			},
			&ast.System{
				Name: "Movement",
				Query: &ast.Query{
					Components: []string{"Position", "Velocity"},
				},
				Code: "    local pos = components.Position\n    local vel = components.Velocity\n    pos.x = pos.x + vel.dx\n    pos.y = pos.y + vel.dy",
			},
			&ast.Relationship{
				Type:   "ChildOf",
				Name:   "Hierarchy",
				Child:  "Transform",
				Parent: "Transform",
			},
		},
	}

	expected := `
-- Generated by EJECS IDL Compiler --
local Module = {}

Module.Components = {}

Module.Components.Position = {
    x = 0,
    y = 0
}

Module.Components.Velocity = {
    dx = 0,
    dy = 0
}

world:system({
    name = "Movement",
    query = {
        all = {
            Position,
            Velocity
        },
    },
    callback = function(entity, components)
        local pos = components.Position
        local vel = components.Velocity
        pos.x = pos.x + vel.dx
        pos.y = pos.y + vel.dy
    end
})

@ChildOf
relationship Hierarchy {
    child: Transform
    parent: Transform
}

return Module
`

	g := New()
	got, err := g.Generate(program)
	if err != nil {
		t.Fatalf("Generate() error = %v", err)
	}
	assertEqualIgnoringWhitespace(t, expected, got)
}

// Helper tests for expression generation (Keep these as they test sub-units)
func TestGenerateExpression(t *testing.T) {
	tests := []struct {
		name      string
		expr      ast.Expression
		expected  string
		expectErr bool
	}{
		{"identifier", &ast.Identifier{Value: "myVar"}, "myVar", false},
		{"number literal", &ast.NumberLiteral{Value: "123.45"}, "123.45", false},
		{"string literal", &ast.StringLiteral{Value: "hello"}, `"hello"`, false},
		{"boolean true", &ast.BooleanLiteral{Value: true}, "true", false},
		{"boolean false", &ast.BooleanLiteral{Value: false}, "false", false},
		{
			name: "simple table constructor",
			expr: &ast.TableConstructor{
				Fields: []*ast.TableField{
					{Key: &ast.Identifier{Value: "a"}, Value: &ast.NumberLiteral{Value: "1"}},
					{Key: &ast.Identifier{Value: "b"}, Value: &ast.StringLiteral{Value: "two"}},
				},
			},
			expected: `{ a = 1, b = "two" }`, // Simplified expectation for whitespace helper
			// expected: `{
			//     a = 1,
			//     b = "two"
			// }`,
		},
		{
			name: "call expression",
			expr: &ast.CallExpression{
				Function: &ast.Identifier{Value: "myFunc"},
				Arguments: []ast.Expression{
					&ast.NumberLiteral{Value: "1"},
					&ast.StringLiteral{Value: "arg2"},
				},
			},
			expected: `myFunc(1, "arg2")`,
		},
		{
			name: "prefix expression",
			expr: &ast.PrefixExpression{
				Operator: "-",
				Right:    &ast.NumberLiteral{Value: "10"},
			},
			expected: `-10`,
		},
		{
			name: "member access",
			expr: &ast.MemberAccessExpression{
				Object:     &ast.Identifier{Value: "myTable"},
				MemberName: &ast.Identifier{Value: "myField"},
			},
			expected: `myTable.myField`,
		},
		// Add more expression tests here
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			g := New() // Need a generator instance for indentation helpers within expressions
			got, err := g.generateExpression(tt.expr)

			if tt.expectErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
				assertEqualIgnoringWhitespace(t, tt.expected, got)
			}
		})
	}
}
